---
layout: post
title: "reversecore_studying"
date: 2019-02-01
author: jjnoob
category: 2019-02
tags: studying
---

> 简单地写写总结，怕忘了。总结写的太详细反而成了鸡肋。这本书还是要好好看的。


# 第二章 逆向分析hello world程序

### (1) OD快捷键
```
Restart   - Ctrl+F2
Step Into - F7
Step Over - F8
Run - F9
Execute till Return - Ctrl+F9
Go to  - Ctrl+G
Edit data  - Ctrl+E
Assemble - Space  //编写汇编代码
Copy to executable  //可以把修改后的代码保存为文件
```
> 另：API函数
API函数，操作系统除了协调应用程序的执行、内存分配、系统资源管理外，同时也是一个很大的服务中心，调用这个服务中心的各种服务（每一种服务是一个函数），可以帮助应用程序达到开启视窗、描绘图形、使用周边设备的目的，由于这些函数服务的对象是应用程序（Application），所以称之为Application Programming Interface，简称API函数。

### (2) 快速查找制定代码的四种方法


##### 1. 代码执行法
不停地摁F8，弹出消息对话框时的函数即为main()函数 

##### 2. 字符串检索法 
search for - all referenced text strings

##### 3. API检索法(1):在调用代码中设置断点
search for - all intermodular calls

##### 4. API检索法(2):在API代码中设置断点

### (3) 修改字符串的两种方法
* 直接修改字符串缓冲区
* 在其他内存区域新建字符串并传递给消息函数

### (4) 小结
##### 1. OllyDbg常用命令

##### 2. Assembly(汇编语言)基础命令
```
CALL  //调用某地址处的函数
JMP  //跳转到某地址处
PUSH  //保存某数到栈
RETN  //跳转到栈中保存的地址
```

##### 3. 修改(Patch)进程数据与代码的方法
使用OllyDbg的编辑数据与汇编功能

##### 4. 术语
* VA (Virtual Address)
* OP code (Operation code)
* PE (Portable Executable)

***

# 第三章 小端序标记法
* 大端序
* 小端序  (此书后续采用)
* 字符数组在内存中时连续的，此事向字符数组存放数据，无论采用大端序还是小端序，存储数据都相同


***

# 第四章，IA-32寄存器基本讲解

> 我已蒙蔽，没看懂。反正这本书我也没准备只看一遍。

> 貌似有四种寄存器。 吧。。

* 通用寄存器
* 段寄存器
* 程序状态与控制寄存器
* 指令指针寄存器

*** 

# 第五章，栈

### (1) 栈内存在进程中的作用如下
* 暂时保存函数内的局部变量
* 调用函数时传递参数
* 保存函数返回后的地址

### (2) 栈的特征
* 栈是一种由高地址向低地址扩展的数据结构
* 栈顶指针为： `ESP`
* 弹出栈顶 `POP EAX`  
* 另：在调试过程中，寄存器的初始值与栈的初址等会随着运行环境的不同而不同

***
# 第六章，分析abex' crackme#1
> EP (EntryPoint, 入口点)
> BP (Break Point, 断点)
> EP是Windows可执行文件(EXE,ELL,SYS等)的代码入口点，是执行应用程序时最先执行的代码起始位置，它依赖于CPU.


### (1) 此处涉及到的汇编指令

```
PUSH  //入栈指令
CALL  //调用指定位置的函数
INC  //值加1
DEC  //值减1
JMP  //跳转到指定地址
CMP  //比较给定的两个操作数 *与SUB命令相似，但操作数的值不会改变，仅改变EFLAGS寄存器
JE  //条件跳转指令
```

### (2)简单地破解

* 此例中，通过汇编命令将 **条件分支语句(JE)** 替换为 **无条件跳转语句(JMP)**
* 再使用Copy to executable命令，将已修改的代码保存为文件
* 打开新保存的文件，done.

另：代码逆向分析技术中，我们有意将已有代码(或数据)覆盖为其他代码的行为称为"打补丁"

### (3)将参数压入栈
对于栈而言，函数调用时的参数顺序(正序)与参数入栈时的顺序(逆序)相反，记住这个就行了。

***

# 第七章 栈帧

### (1)栈帧 (Stack Frame)
* ESP寄存器承担着栈顶指针的作用, 而EBP寄存器则负责行使栈帧指针的职能. 
* 程序运行时, ESP寄存器的值会随之变化, 所以不能以ESP值为基准编写函数. 因此在调用某函数之前, 要先把基准点(函数起始地址)的ESP值保存到EBP, 并维持在函数内部. 
* 以EBP的值为基准(base)能够安全访问到相关函数的局部变量,参数,返回地址. 这就是EBP寄存器作为栈帧指针的作用. 
* 另: 最新的编译器(本书2014.5出版)都带一个"优化" (Optimiziation) 选项,使用该选项编译简单的函数将不会生成栈帧

### (2)

> ## 持续更新中

> ## END



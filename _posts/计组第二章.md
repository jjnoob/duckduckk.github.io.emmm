---
title: "计组第二章"
tags: [studying]
---


> ### 第二章，上课啥都没听。。。。。自己从PPT，书上，百度上，复制粘贴 总结的

# **一，计算机中数值的表示方法**

### 1. 编码
编码：将非二进制形式表示的数值型数据转化为二进制形式表示，并最终实现在计算机的存储和处理的过程。 


### 2. 机器数与真值
一个数在计算机（机器）中的存储形式，称为机器数。、而这个以二进制形式表示的数的数值本身，称为该数的真值；真值的正负号用+和-表示的。而机器数的正负号使用0和1表示的。 

机器数的表示位数受计算机系统的的数据位数限制。计算机系统为32位或者64位，则机器数也将是32位或者64位的。 
#### 举例 
* 真值+52（十进制表示的真值） = +110100B（二进制形式的真值） 
    8位机器数：0011 0100 16位机器数：0000 0000 0011 0100 
* 真值-52 = -110100 
    8位机器数：1011 0100 16位机器数：1000 0000 0011 0100

### 3. 无符号数和有符号数
对于机器数，不需要考虑符号时，可以使用无符号数，这个时候，所有的二进制数位表示数的大小。这样，8位的二进制数能表示的最小数是0，最大值是2^8 -1 = 256 -1=255 
对于需要正负特征的数，就用最高位表示符号，用剩余的低数码位表示绝对值，此时为带符号数。有符号数为了简化计算，又引入了原码，反码，补码的概念。

### 4. 原码、反码、补码

其实我们首先要注意的是，原码、反码、补码都是机器数的具体表现形式。这样它们都符合机器数的基本特点，就是最高位为符号位，0表示正数，1表示负数；其余位是数值位。数值位是原码、反码补码的不同之处。 
* 原码的数值位 与真值的数值位相同 
* 反码的数值位 原码的数值位取反   // 0变1，1变0
* 补码的数值位 正数的数值位与原码相同，负数的数值位为反码加1

# **二，定点数和浮点数的表示**

一般来说，定点格式可表示的数值的范围有限，但要求的处理硬件比较简单。而浮点格式可表示的数值的范围很大，但要求的处理硬件比较复杂。

### 1，定点数：如果一个数中小数点的位置是固定的，则为定点数（**符号+量值**）


原理上来讲，小数点位置固定在哪一位都可以，但是通常将数据表示成纯小数或纯整数

* 如果是纯小数，则小数点在 **符号** 和 **量值** 之间
* 如果是纯整数，则小数点在 **量值** 的右边

### 2，浮点数：如果一个数中小数点的位置是浮动的，则为浮点数

浮点数是一种公式化的表达方式，用来近似表示实数.

浮点数通常被表示为：

**N=M×R^E**
比如： 12.345=1.2345×10^1

其中
* M被称为浮点数的 尾数
* R被称为阶码的 基数
* E被称为阶的 阶码
* 计算机中一般规定R为2、8或16，是一个确定的常数，不需要在浮点数中明确表示出来。

通常，我们可以用下面的格式来表示浮点数

| **S符号位** | P阶码 | M尾数 |
--|:--:|--:


# **三，IEEE754标准的32位，64位浮点数的表示格式**
  
| **S符号位** | E阶码 | M尾数 |
--|:--|--:

### 1, 32位：
* S=0表示正数，S=1表示负数，占一位
* E占用8位，采用移码方法来表示正负指数 （阶码域值大者其指数值也大。将浮点数的指数真值e变成阶码E时，应将指数e加上一个固定的偏移值127(01111111),即 E=e+127 ）
* M放在最低位，占用23位，小数点放在尾数域最左有效位的右边
* 另，当尾数的值不为0时，尾数域的最高位应为1，(即**规格化**)故尾数域所表示的值是 **1.M** 
* x=(-1)^s * (1.M) * 2^(E-127)
    e=E-127
### 2, 64位：

* S 符号位1位
* E 阶码域11位
* M 尾数域52位
* 指数偏移值是1023
* x=(-1)^s * (1.M) * 2^(E-1023)
    e=E-1023


# **四，浮点数的规格化表示，为什么要进行规格化，规格化的定义以及如何进行规格化**

### 1, 浮点数的规格化表示：

见 **三**

### 2, 为什么要进行规格化：

因为不进行规格化的话，同一个数会有不同的表示方法   (与指数同理)

### 3, 规格化的定义：

当尾数的值不为0时，尾数域的最高位应为1，这称为浮点数的规格化表示

### 4，如何进行规格化：
这个要去刷题才能懂

# **五，十进制数串的表示方法**

* 字符串的形式：一个字节存放一个十进制的数位或符号位。
    主要用于非数值计算。
* 压缩的十进制数串形式：一个字节存放两个十进制的数位。
    是广泛采用的较为理想的方法。

# **六，数的机器码表示**

### 1, 原码表示法
(1) 定点小数原码定义 

若x=x0. x1 …. xn 

* **[x]原=**
   * **x**            ( 0≤x<1 )
   * **1＋|x|**       ( -1<x≤0 )


例：
    x=＋0.1101，则[x]原=0.1101
    x=－0.1101，则[x]原=1.1101

(2) 定点整数原码定义

若x=x0 x1 …. xn 
* **[x]原=**
   * **x**                ( 0≤x<2n )
   * **2^n+|x|**           ( -2n<x≤0 )

例：
x=＋1101，则[x]原=01101
x=－1101，则[x]原=11101

(3) 浮点数原码定义
阶码 部分按照定点整数的方法进行编码
尾数 部分按照定点小数的方法进行编码

### 2, 补码表示法 



(1)定点正数正数，求5的补码：

* 5的补码即为它的二进制形式：
    00000101

(2)定点负数，求-5的补码：

* 先将-5取绝对值然后写出其二进制形式
    00000101
* 按位取反
    11111010
* 加1
    11111011

(3)定点负数，求-10的补码：

* 先将-10取绝对值然后写出其二进制形式
    00001010
*  按位取反
    11110101
* 加1
    11110110

(4)定点小数
* **[x]补=** 
   * **x**   (0<x<1)
   * **2–|x|**  (-1<x<0)

例:  
x= + 0.1011, 则 [x]补=0.1011
x= - 0.1011, 则 [x]补=10 + x = 10.0000-0.1011= 1.0101

(5)浮点数补码定义
阶码 部分按照定点整数的方法进行编码
尾数 部分按照定点小数的方法进行编码

### 3, 反码的表示法
(1)定点小数：

* x[反]=
   * x (0≤x<1)
   * (2+x−2^n (−1<x≤0)

例:
x=0.1011,x[反]=0.1011
x=-0.1011,x[反]=1.0100

(2)定点整数：
对于一个带符号的数来说
* 正数的反码与其原码相同
* 负数的反码为其原码除符号位以外的各位按位取反

例:
x= 1011,x[反]=01011
x=-1011,x[反]=10100

(3)浮点数：
* 浮点数反码定义
    阶码部分按照定点整数的方法进行编码
    尾数部分按照定点小数的方法进行编码

### 4, 移码的表示法：
* 移码用于表示浮点数的阶码

* x[移]=2n+x (−2n≤x<2n)
* 例:
x=+1011,x[移]=11011
x=-1011,x[移]=00101

* 正数是把符号位变成 1 ，其余不变。
* 负数则 包括**符号位**在内**取反**再**加一**

# **七，字符与字符串的表示方法**

### 1, 七单位的ASCII码

普遍采用的字符系统：七单位的ASCII码（美国国家信息交换标准字符码)

### 2, 汉字编码
* 输入编码：
   * 数字编码
   * 拼音码
   * 字形编码
* 机内编码：一般用两个字节来实现
* 输出编码：字模码

### 3, 校验码
* 检错码：奇偶校验码——只能检出一位错误，无法定位
* 纠错码
   * 海明码：多重奇偶校验位
   * 循环冗余校验码


# **八，奇偶校验码**

* 如果是奇校验加上校验位后,编码中1的个数为奇数个。如果是偶校验加上校验位后,编码中1的个数为偶数个。
* 当原编码在传输、储存的过程中发生了误码，1的数量就会改变，然后就能校验出该过程出现了错误。

### **例如,水平奇偶校验码:** (垂直奇偶校验同理)
| **原编码** | 奇校验 | 偶校验 |
--|:--|--:
0000 | 0000 1 | 0000 0
0010 | 0010 0 | 0010 1
1100 | 1100 1 | 1100 0
1010 | 1010 1 | 1010 0

### 缺点很多，例如：

设原编码为0000，传输的过程中变成了1001。如果使用奇校验，原编码是00001，传输过后会变成10011，1仍然是奇数个，无法校验；如果使用偶校验，原编码是00000，传输过后会变成10010，1仍然是偶数个，同样无法校验。



# **九,补码的加减法**

假定了A,B都是正数

* 加法：
整数： [A]补 + [B]补 = [A+B]补 （mod 2^(n+1)） 
小数： [A]补 + [B]补 = [A+B]补 （mod 2）

* 减法： 
整数： [A-B]补 = [A]补 + [-B]补 （mod 2^(n+1)） 
小数： [A-B]补 = [A]补 + [-B]补（mod 2） 
[-B]补的求法就是 [B]补的连同符号位在内，每位求反加一

#### 例：
A = +15, B = +24，求[A-B]补
#### 换成二进制原码：

A = +15 = 0,0001111;
B = +24 = 0,0011000 

#### 换成补码：
[A]补 = 0,0001111,
[B]补 = 0,0011000，
[-B]补 = 1,1101000

[A-B]补 = [A]补 + [-B]补
0,0001111 +1,1101000 
= 1,1110111

> ### **另,补码的求法：**

1,正数，求5的补码：

* 5的补码即为它的二进制形式：
    00000101

2,负数，求-5的补码：

* 先将-5取绝对值然后写出其二进制形式
    00000101
* 按位取反
    11111010
* 加1
    11111011

3，负数，求-10的补码：

* 先将-10取绝对值然后写出其二进制形式
    00001010
*  按位取反
    11110101
* 加1
    11110110

# **十,溢出的概念及判断方法**

### 1, 溢出的概念：
在定点整数机器中，书的表示范围|x|<(2^n -1)。在运算过程中如果出现大于字长绝对值的现象，称为溢出。在定点机中，正常情况下溢出是不允许的。
* 两个正数相加，结果大于机器字长所能表示的最大正数，称为正溢。

* 两个负数相加，结果小于机器所能表示的最小负数，称为负溢。

### 2，溢出的检测方法：

(1)双符号位法(变形补码)
* 采用变形补码后，任何正数，两个符号位都是0，即00Xn-1Xn-2...X0;
* 任何负数，两个符号位都是1，即11Xn-1Xn-2...X0.
* 两个数相加后，若结果的符号位出现"01"或"10"，则表示溢出。

例如,x=+1100,y=+1000,求x+y.
    [x]补=**00**1100，[y]补=**00**1000
    两者相加得到[x+y]补，观察结果的两个符号位即可。

* 运算结果的二符号位相异时，表示溢出；相同时表示未溢出，故溢出逻辑表达式为V=S1^S2 (异或门)


(2)单符号位法
* 当**最高有效位**产生进位而**符号位**无进位时，产生正溢；
* 当**最高有效位**无进位而**符号位**有进位时，产生负溢；
* 逻辑表达式V=C1^C2 (异或门)

#### 另，异或门：
* 若两个输入的电平相异，则输出为高电平1；若两个输入的电平相同，则输出为低电平0。
* 逻辑表达式：F=A^B=A&B'+A'&B ("^"为异或标志)

# **十一，定点乘法运算**

### 1, 定点加法、减法运算 (顺便了解)

* 目前计算机普遍采用补码实现加减法
* 若求x+y,则先求出 **x补** 和 **y补** ，两者相加，得到 **[x+y]补** ,去掉溢出部分，再求补码，得到 **[x+y]原**

### 2, 人工算法

* 运算规则：符号位和数值部分(绝对值)分别运算
* 手工运算过程和正常的乘法一样，依次相乘。

### 3, 带求补器的原码阵列乘法器(不带符号的阵列乘法器)

> **第一遍看ppt懂了，不太会，自行看ppt** 。。。。。。。

### 4, 带求补器的补码阵列乘法器(带符号的阵列乘法器)

> **第一遍看ppt懂了，不太会，自行看ppt** 。。。。。。。


# **十二，定点除法运算**

### 1, 原码恢复余数法

* 人工除法时，人可以比较被除数（余数）和除数的大小来确定商1（够减）或商0（不够减） 

* 机器除法时，余数为正表示够减，余数为负表示不够减。不够减时必须恢复原来余数，才能继续向下运算。这种方法叫恢复余数法，控制比较复杂

* 左移相当于乘2(ppt上说的)
    右移就是直接右移，空出的地方补零(据我观察)

### 2, 原码不恢复余数法(加减交替法)

实际上常用不恢复余数法，又称加减交替法。其特点是运算过程中如出现不够减，则不必恢复余数，根据余数符号，可以继续往下运算，因此步数固定，控制简单。 

**原码加减交替法的规则是：**
* 当余数为正时，商“1”，余数左移一位,下一步做**减**除数；
* 当余数为负时，商“0”，余数左移一位,下一步做**加**除数；
* 商的位数等于除数位数，即可停止。

### 3, 并行除法器(采用不恢复余数法)

* 当输入线P＝0时， CAS作加法运算；当P＝1时，CAS作减法运算。

* Si=Ai  ^(Bi ^ P) ^ Ci
    Ci+1=AiBi+BiCi +AiCi

* 原理基本与加减交替法相同，只是，加减交替法中除数是**左移**，而并行除法器中除数是**右移**。


# **十三，定点运算器的组成** 

### -1, 逻辑运算(了解)

* 逻辑非运算：求反，在数上面加一横；
* 逻辑加运算：逻辑或、‘∨’ ，  ‘＋’；
* 逻辑乘运算：逻辑与、‘∧’  ，‘·’ ， ‘×’；
* 逻辑异运算：异或、模2的和、按位加、 ‘ ^ ’；

### 1, ALU

* 可以实现实现并行进位(先行进位)
* 实现16种算术运算，16种逻辑运算
* 一位全加器FA的逻辑表达式：
   * Fi= Xi ^ Yi ^ Cn+i
   * **C**n+i+1=**X**i**Y**i+**Y**i**C**n+i+**C**n+i**X**i
   * i代表在一片电路中的第几位；n代表若干片ALU组成一个运算器的每片电路的进位输入.
* 为了实现多种算术逻辑运算，可将Ai和Bi输入一个函数发生器（进位传递函数和进位产生函数）得到输出Xi和Yi，作为一位全加器的输入

### 2, 先行加法器与进位链逻辑

* 第0位向第1位进位公式：
    Cn+1 = Y0 + X0Cn
* 第1位向第2位进位公式：
    Cn+2 = Y1+X1Cn+1 = Y1 + Y0X1 + X0X1Cn
* 第2位向第3位进位公式：
    Cn+3 = Y2 + X2Cn+2 = Y2 + Y1X2 +Y0X1X2 + X0X1X2Cn
* 第3位进位输出为：
    Cn+4 = Y3 + Y2X3 + Y1X2X3 + Y0X1X2X3 + X0X1X2X3Cn
* 设G = Y3 + Y2Y3 + Y1X2X3 + Y0X1X2X3
    P =  X0X1X2X3
 则 Cn+4 = G + PCn

* 其中G称为**进位发生输出**，P称为**进位传送输出**，在电路中加入这两个进位输出的目的，是为了便于实现多片ALU之间的先行进位，为此需要一个配合电路，称为**先行进位发生器(CLA)**。Cn+4是本片的最后进位输出，从逻辑表达式可以得到，本片的最低进位Cn可以直接传送到最高进位位上去，从而可实现高速运算。
> ### 一串公式看的有点晕，建议去看ppt，那上面很清晰。

### 3, SN 741**81**

* 逻辑电路图自行看ppt
* M=L时，对进位信号没有影响，做算术运算
    M=H时，进位门被封锁，做逻辑运算

* A=B端可以判断两个数是否相等。
* 芯片有两种工作方式：正逻辑操作方式和负逻辑操作方式。但是在执行算术运算时，输入/输出都是等效的。

### 4, 两级先行进位的ALU

* 用四片74181ALU的P、G输入到 74182**先行进位部件**( CLA)，可以实现第二级的先行进位，即组与组之间的先行进位。
* G * = G3+G2P3+G1P1P2+G0P1P2P3     成组进位 **发生** 输出
    P * =  P0P1P2P3                 成组进位 **传送** 输出  
* 设置P* 和 G*的目的是为了进一步的使4个74181ALU级 联一个74182 CLA。方便了成组之间的进位产生。


# **十四，浮点数加减运算的基本步骤**
* 需要多做题才能懂
### 1, 结果规格化处理 [M]补
* 无需规格化：
00.1 x x …x
11.0 x x …x

* **左移**规格化：
00.0 x x …x
11.1 x x …x
* **右移**规格化：
10.x x x …x
01.x x x …x

### 2, 看例题就好：

例   设ｘ=2^010 *0.11011011, ｙ=2^100 *(-0.10101100), 求ｘ+ｙ。
解：  阶码采用双符号位, 尾数采用单符号位,  则它们的浮点表示分别为 
* [x]浮= 00 010,　 00.11011011            
* [y]浮= 00 100,　 11.01010100
#### (1)  求阶差并对阶
△E = Ex- Ey= [Ex]补+ [-Ey]补= 00 010 + 11 100 = 11 110
即△E为-2,  x的阶码小,   应使 Mx右移两位,  Ex加2,
[x]浮＝00 100,  00.00110110(11)
其中(11)表示Mｘ右移2位后移出的最低两位数。
#### (2)尾数求和
 00.00110110(11) + 11.01010100 = 11.10001010(11)
#### (3) 规格化处理
尾数运算结果的符号位与最高数值位为同值，应执行左规处理，结果为11.00010101(10)， 阶码为00 011。
#### (4) 舍入处理
采用0舍1入法处理, 则有:
  11.00010101 + 1 = 11.00010110
#### (5) 判断溢出
   阶码符号位为00，不溢出，故得最终结果为
     x + y = 2011 × (-0.11101010)

# **十四，浮点数乘除运算基本步骤** 
* 需要多做题才能懂

### 1，尾数结果规格化
当Mx和My都不为0时，相乘后结果一定在下列范围内：1/4≤| Mx×My |＜1
* 当1/2 ≤| Mx×My |＜1时，尾数已经是规格化数。
* 当1/4≤| Mx×My |＜1/2时，需要左规一次

### 2，首先需要保证|Mx | ＜|My |，如果不小于，则Mx需要右移一位

### 3，直接上例题：

例：设有浮点数ｘ＝2^(-5) ×0.0110011,ｙ＝2^3 × (-0.1110010),阶码用4位补码表示,尾数(含符号位)用8位原码表示,求[ｘ×ｙ]浮。

**解**：
阶码采用双符号位,尾数原码采用单符号位,则有　
[Mx]原=0.0110011 , [My]原=1.1110010　
[Ex]补=11011 , [Ey]补=00011 
[x]浮=11011, 0.0110011 , [y]浮=00011, 1.1110010

##### (1) 求阶码和：
[Ex]补+[Ey]补=11011+00011=11110 (补码形式-2)
##### (2) 尾数乘法运算可采用原码阵列乘法器实现
即有　[Mx]原×[My]原 = [0.0110011]原×[1.1110010]原= [1.0101101,0110110]原
##### (3) 规格化处理:
乘积不是规格化的数，需要左规。尾数左移1位变为1.1011010,1101100 , 阶码变为11101 (-3)。注：这里的-3是由(1)里面的结果 求补 再因为对阶的原因，右移2 位得到的。
##### (4) 舍入处理：
尾数为负数，取高位字长，按舍入规则舍去低位字长，故尾数为1.1011011 。　最终相乘结果为 [x*y]浮=11101, 1.1011011　　其真值为 x * y=2^(-3) * (-0.1011011)

# **十五，对阶的定义，结果规格化，左移规格化，右移规格化**

### 1，对阶
* 使二数阶码相同（即小数点位置对齐），这个过程叫作对阶
* 先求两数阶码 Ex 和 Ey之差，即△E = Ex－Ey
* 阶码小的数向阶码大的数对齐，小阶的尾数右移△E 位

### 2，结果规格化(二进制)
* 两数相加相乘的结果S必须 0.5≤|S|<1 ，否则就进行左移规格化和右移规格化
* 需要多做题才能懂。


> ## END

参考了很多资料，我写的太乱了，没能附上链接。一并感谢！
